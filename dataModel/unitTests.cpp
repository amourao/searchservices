#include "unitTests.h"

void DataModelTests::storeAndLoadNKeypoints(){
	vector<pair<vector<float>,vector<float> > > v;
	vector<float> first;
	vector<float> second;
	vector<float> third;
	vector<float> forth;
	first.push_back(1.5);
	first.push_back(43.1);
	first.push_back(654.7);
	first.push_back(21.6);
	second.push_back(96.4);
	second.push_back(12.0);
	second.push_back(2.2);
	third.push_back(37.14);
	third.push_back(41.01);
	forth.push_back(57.65);
	forth.push_back(5.3);
	forth.push_back(73.36);
	forth.push_back(85.58);
	forth.push_back(20.01);
	pair<vector<float>,vector<float> > pair1(first,second);
	pair<vector<float>,vector<float> > pair2(third,forth);
	v.push_back(pair1);
	v.push_back(pair2);
	IDataModel* keypoints = new NKeypoint("/path/to/something/","keypoints", v);
	keypoints->storeSQL();
	IDataModel* keypoints2 = new NKeypoint("keypoints");
	keypoints2->loadSQL(1);
	vector<pair<vector<float>,vector<float> > > v2 = *static_cast<vector<pair<vector<float>,vector<float> > >* > (keypoints2->getValue());
	TEST_ASSERT(v2.size() == v.size());
	TEST_ASSERT(v[0].first[1] == v2.at(0).first[1]);
	TEST_ASSERT(v[0].first[1] == v2.at(0).first[1]);
	TEST_ASSERT(v[0].first[1] == v2.at(0).first[1]);
	TEST_ASSERT(v[0].first[2] == v2.at(0).first[2]);
	TEST_ASSERT(v[0].first[3] == v2.at(0).first[3]);
	TEST_ASSERT(v[0].second[0] == v2.at(0).second[0]);
	TEST_ASSERT(v[0].second[1] == v2.at(0).second[1]);
	TEST_ASSERT(v[0].second[2] == v2.at(0).second[2]);
	TEST_ASSERT(v[1].first[0] == v2.at(1).first[0]);
	TEST_ASSERT(v[1].first[1] == v2.at(1).first[1]);
	TEST_ASSERT(v[1].second[0] == v2.at(1).second[0]);
	TEST_ASSERT(v[1].second[1] == v2.at(1).second[1]);
	TEST_ASSERT(v[1].second[2] == v2.at(1).second[2]);
	TEST_ASSERT(v[1].second[3] == v2.at(1).second[3]);
	TEST_ASSERT(v[1].second[4] == v2.at(1).second[4]);
}

void DataModelTests::storeAndLoadNVector(){
	vector<float> v;
	v.push_back(1.5);
	v.push_back(43.1);
	v.push_back(654.7);
	v.push_back(21.6);
	v.push_back(96.4);
	v.push_back(12.0);
	v.push_back(2.2);
	v.push_back(37.14);
	v.push_back(41.01);
	v.push_back(57.65);
	v.push_back(5.3);
	v.push_back(73.36);
	v.push_back(85.58);
	v.push_back(20.01);
	IDataModel* vec = new NVector("/something/","vector",v);
	vec->storeSQL();
	IDataModel* vec2 = new NVector("vector");
	vec2->loadSQL(2);
	vector<float> v2 = *static_cast<vector<float>* > (vec2->getValue());
	TEST_ASSERT(v.size() == v2.size());
	TEST_ASSERT(v[0] == v2[0]);
	TEST_ASSERT(v[1] == v2[1]);
	TEST_ASSERT(v[2] == v2[2]);
	TEST_ASSERT(v[3] == v2[3]);
	TEST_ASSERT(v[4] == v2[4]);
	TEST_ASSERT(v[5] == v2[5]);
	TEST_ASSERT(v[6] == v2[6]);
	TEST_ASSERT(v[7] == v2[7]);
	TEST_ASSERT(v[8] == v2[8]);
	TEST_ASSERT(v[9] == v2[9]);
	TEST_ASSERT(v[10] == v2[10]);
	TEST_ASSERT(v[11] == v2[11]);
	TEST_ASSERT(v[12] == v2[12]);
	TEST_ASSERT(v[13] == v2[13]);
}

void DataModelTests::storeAndLoadGameImage(){
	int gameId = 6;
	int roundId = 7;
	int userId = 8;
	int timeId = 9;
	int roundAudience = 10;
	int roundExpressionId = 11;
	int ksvm = 12;
	float score = 13;
	vector<float> v;
	vector<float> v1;
	vector<float> v2;
	vector<float> v3;
	vector<float> v4;
	vector<float> v5;
	v.push_back(1.5);
	v.push_back(43.1);
	v1.push_back(654.7);
	v1.push_back(21.6);
	v2.push_back(96.4);
	v2.push_back(12.0);
	v3.push_back(2.2);
	v3.push_back(37.14);
	v4.push_back(41.01);
	v4.push_back(57.65);
	v5.push_back(5.3);
	v5.push_back(73.36);
	v.push_back(85.58);
	v1.push_back(20.01);
	NVector* x = new NVector("path//","FACE_GABOR",v);
	NVector* x1 = new NVector("path//","FACE_HIST",v);
	NVector* x2 = new NVector("path//","FACE_RECON",v);
	NVector* x3 = new NVector("path//","SHIRT_GABOR",v);
	NVector* x4 = new NVector("path//","SHIRT_HIST",v);
	NVector* x5 = new NVector("path//","SHIRT_RECON",v);
	string username = "somePlayer";
	GameImage* gm = new GameImage("path//",gameId,roundId,userId,timeId,
			roundAudience,roundExpressionId,ksvm,score,username,*x,*x1,*x2,*x3,*x4,*x5);
	gm->storeSQL();
	GameImage* gm2 = new GameImage();
	gm2->loadSQL(3);
	TEST_ASSERT(gameId = gm2->getGameId());
	TEST_ASSERT(roundId = gm2->getRoundId());
	TEST_ASSERT(userId = gm2->getUserId());
	TEST_ASSERT(timeId = gm2->getTimeId());
	TEST_ASSERT(roundAudience = gm2->getRoundAudience());
	TEST_ASSERT(roundExpressionId = gm2->getRoundExpressionId());
	TEST_ASSERT(ksvm = gm2->getKsvm());
	TEST_ASSERT(score = gm2->getScore());
	TEST_ASSERT(username.compare(gm2->getUsername()) == 0);
}

void DataModelTests::storeAndLoadNTag()
{
	map<string,float> m;
	m["A"] = 1.5;
	m["B"] = 43.1;
	m["C"] = 654.7;
	m["D"] = 21.6;
	m["E"] = 96.4;
	m["F"] = 12.0;
	m["G"] = 2.2;
	m["H"] = 37.14;
	m["I"] = 41.01;
	m["J"] = 57.65;
	m["K"] = 5.3;
	m["L"] = 73.36;
	m["M"] = 85.58;
	m["N"] = 20.01;
	IDataModel* tags = new NTag("/tag/path", m);
	tags->storeSQL();
	IDataModel* tags2 = new NTag();
	tags2->loadSQL(4);
	map<string,float> m2 = *static_cast<map<string,float> *> (tags->getValue());
	TEST_ASSERT(m["A"] == m2["A"]);
	TEST_ASSERT(m["B"] == m2["B"]);
	TEST_ASSERT(m["C"] == m2["C"]);
	TEST_ASSERT(m["D"] == m2["D"]);
	TEST_ASSERT(m["E"] == m2["E"]);
	TEST_ASSERT(m["F"] == m2["F"]);
	TEST_ASSERT(m["G"] == m2["G"]);
	TEST_ASSERT(m["H"] == m2["H"]);
	TEST_ASSERT(m["I"] == m2["I"]);
	TEST_ASSERT(m["J"] == m2["J"]);
	TEST_ASSERT(m["K"] == m2["K"]);
	TEST_ASSERT(m["L"] == m2["L"]);
	TEST_ASSERT(m["M"] == m2["M"]);
	TEST_ASSERT(m["N"] == m2["N"]);
}

void DataModelTests::storeAndLoadNRoi(){
	map<string,region> v;
	region r1;
	r1.x = 10;
	r1.y = 20;
	r1.width = 30;
	r1.height = 40;
	r1.annotationType = "carro";
	region r2;
	r2.x = 1;
	r2.y = 2;
	r2.width = 3;
	r2.height = 4;
	r2.annotationType = "carro";
	region r3;
	r3.x = 34;
	r3.y = 23;
	r3.width = 456;
	r3.height = 356;
	r3.annotationType = "face";
	v["A"] = r1;
	v["B"] = r2;
	v["C"] = r3;
	IDataModel* roi = new NRoi("/some/path", v);
	roi->storeSQL();
	IDataModel* roi2 = new NRoi();
	roi2->loadSQL(5);
	map<string,region> v2 = *static_cast<map<string,region> *> (roi2->getValue());
	TEST_ASSERT(v["A"].x == v2["A"].x);
	TEST_ASSERT(v["A"].y == v2["A"].y);
	TEST_ASSERT(v["A"].width == v2["A"].width);
	TEST_ASSERT(v["A"].height == v2["A"].height);
	TEST_ASSERT(v["A"].annotationType == v2["A"].annotationType);
	TEST_ASSERT(v["B"].x == v2["B"].x);
	TEST_ASSERT(v["B"].y == v2["B"].y);
	TEST_ASSERT(v["B"].width == v2["B"].width);
	TEST_ASSERT(v["B"].height == v2["B"].height);
	TEST_ASSERT(v["B"].annotationType == v2["B"].annotationType);
	TEST_ASSERT(v["C"].x == v2["C"].x);
	TEST_ASSERT(v["C"].y == v2["C"].y);
	TEST_ASSERT(v["C"].width == v2["C"].width);
	TEST_ASSERT(v["C"].height == v2["C"].height);
	TEST_ASSERT(v["C"].annotationType == v2["C"].annotationType);
}

int main(){
	SQLite::Connector::registerConnector();
	Session ses("SQLite", "slb.db");
	ses << "BEGIN", Keywords::now;
	ses << "DROP TABLE IF EXISTS media", Keywords::now;
	ses << "DROP TABLE IF EXISTS word", Keywords::now;
	ses << "DROP TABLE IF EXISTS keypoints", Keywords::now;
	ses << "DROP TABLE IF EXISTS vector", Keywords::now;
	ses << "DROP TABLE IF EXISTS FACE_GABOR", Keywords::now;
	ses << "DROP TABLE IF EXISTS FACE_HIST", Keywords::now;
	ses << "DROP TABLE IF EXISTS FACE_RECON", Keywords::now;
	ses << "DROP TABLE IF EXISTS SHIRT_GABOR", Keywords::now;
	ses << "DROP TABLE IF EXISTS SHIRT_HIST", Keywords::now;
	ses << "DROP TABLE IF EXISTS SHIRT_RECON", Keywords::now;
	ses << "DROP TABLE IF EXISTS gameImage", Keywords::now;
	ses << "DROP TABLE IF EXISTS autoAnnotation", Keywords::now;
	ses << "DROP TABLE IF EXISTS annotationType", Keywords::now;
	ses << "DROP TABLE IF EXISTS region", Keywords::now;
	ses << "CREATE TABLE gameImage (pk INTEGER, gameId INTEGER, roundId INTEGER, userId INTEGER, timeId INTEGER, roundAudience INTEGER, roundExpressionId INTEGER,ksvm INTEGER,score REAL,username TEXT)", Keywords::now;
	ses << "CREATE TABLE media (id INTEGER PRIMARY KEY AUTOINCREMENT, uri TEXT, partOf, FOREIGN KEY(partOf) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE annotationType (id INTEGER PRIMARY KEY AUTOINCREMENT, description TEXT, typeName TEXT)", Keywords::now;
	ses << "CREATE TABLE word (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, type TEXT, annotationTypeId, FOREIGN KEY(annotationTypeId) REFERENCES annotationType(id))", Keywords::now;
	ses << "CREATE TABLE keypoints (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE autoAnnotation (wordId INTEGER, mediaId INTEGER, importance REAL, FOREIGN KEY(wordId) REFERENCES word(id), FOREIGN KEY(mediaId) REFERENCES media(id), PRIMARY KEY(wordId,mediaId))", Keywords::now;
	ses << "CREATE TABLE vector (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE FACE_GABOR (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE FACE_HIST (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE FACE_RECON (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE SHIRT_GABOR (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE SHIRT_HIST (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;
	ses << "CREATE TABLE SHIRT_RECON (id INTEGER PRIMARY KEY AUTOINCREMENT, mediaId, data BLOB, FOREIGN KEY(mediaId) REFERENCES media(id))", Keywords::now;

	ses << "CREATE TABLE region (mediaId PRIMARY KEY, x INTEGER, y INTEGER, height REAL, width REAL, annotationTypeId, FOREIGN KEY(mediaId) REFERENCES media(id), FOREIGN KEY(annotationTypeId) REFERENCES annotationType(id))", Keywords::now;
	ses << "INSERT INTO annotationType VALUES(null,\"face\",\"face\")", Keywords::now;
	ses << "INSERT INTO annotationType VALUES(null,\"carro\",\"carro\")", Keywords::now;
	ses << "END", Keywords::now;
	ses.close();
	SQLite::Connector::unregisterConnector();
	DataModelTests sts;
	Test::TextOutput output(Test::TextOutput::Verbose);
	return sts.run(output, false); // Note the 'false' parameter*/
}
